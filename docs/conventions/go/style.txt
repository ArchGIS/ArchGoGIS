## Objects

[obj recv]
Правило:
 Любой receiver метода называется my.
Обоснование:
 Для консистентности и избежания коллизий имён.
 Тем более my.x (мой x) звучит не хуже this.x, да ещё и кратче.

## Packages.

[pkg init]
Правило:
 Если внутри пакета есть init функция, она должна быть объявлена
 в файле init.go
Обоснование:
 Так проще находить пакеты, которые выполняют дополнительную
 инициализацию (которая может содержать побочные эффекты).

[pkg type file]
Правило:
 Все объявления типов в файле types.go, локальном для пакета.
Обоснование:
 1) Так гораздо проще искать какие же типы предоставляет пакет.
 Нагляднее видно, какие из них экспортируемые, а какие - нет.
 2) Структуры, для которых написаны методы - это
 довольно низкоуровневая и не очень стабильная деталь интерфейса,
 поэтому её можно выносить в отдельный файл.
 3) Не всегда название файла соответствует названию типа.
 Иногда в файле бывает более одного типа с методами, а иногда
 файл вообще не содержит в себе типов.

[pkg type ctor]
Правило:
 Все конструкторы для типов также хранятся внутри types.go.
Обоснование:
 1) Это позволяет делать меньше импортов внутри кода реализации.
 2) Конструирующие функции (NewType) - это не методы,
 поэтому им лучше не находиться внутри файла реализации типа (где одни методы)

[pkg impl file name]
Правило:
 Если у типа из types.go есть методы, они реализуются в файле,
 который называется также, как и тип.
Пример:
 types.go содержит
 type FooBar struct {}
 и при этом для FooBar планируется писать методы,
 тогда в директории пакета должен быть файл `foo_bar.go`
Обоснование:
 Усиливает правило [pkg type file]

